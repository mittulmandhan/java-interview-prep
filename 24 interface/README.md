# Interface
* `interface` is a keyword.
* Interface solves the Diamond Problem and enables Multile Inheritance in Java.
* Interfaces are written in .java files and generated bytecode is the .class file.
![picture alt](https://github.com/mittulmandhan/java-interview-prep/blob/master/img/interface/interface%20bytecode.jpg)
* Interface is declared using `interface` keyword.
````
interface A {
}
````
* An interface contain abstract methods only.
* Interface cannot contain normal methods.
* Interface does not have constructors.
* Interface caanot be instantiated.
````
interface A {
}
````
````
class B {
  public static void main(String[] args) {
    // this line will not compile 
    // because we are trying to instantiate
    // interface A's object
    new A();
  }
}
````
* Reference variable of interface can be created.
````
interface A {
}
````
````
class B {
	public static void main(String[] args) {
		// compiler will not give error here
		// because we are not instantiating interface A
		// we are just creating a reference variable of type A
		A a = null;
	}
}
````
* By default interface is abstract i.e. it is considered as pure abstract.
* By default all the methods in an interface are `public abstract`.
````
interface A {
  public abstract void ab();
  // following line will be changed to
  // public abstract void my();
  // It is done by compiler
  void my();
}
````
* Interface can contain variables.
````
interface A {
  // following line will be changed to
  // public static final int x=10;
  // It is done by compiler
  int x=10;
}
````
* Interfaces which does not contain any member is called Marker Interface. For eg: Serializable, Clonable, Remote, etc.
````
interface Serializable {
}
````
* Inheriting interfaces in Java:
![picture alt](https://github.com/mittulmandhan/java-interview-prep/blob/master/img/interface/inheriting%20interfaces.png)
````
interface A {
}
````
````
// interface extending interface
interface B extends A {
}
````
````
// class implements interface
class C implements B {
}
````
````
// class extends class
class D extends C {
}
````
* No interface cannot extend a class.
## Multiple Inheritance
* Multiple Inheritance is a type of inheritance where a class inherits more than one classes.
* Multiple inheritance in OOPS also lead to __Diamond Problem__.
![picture alt](https://github.com/mittulmandhan/java-interview-prep/blob/master/img/interface/diamond%20problem.jpg)
<br>As we can see from the figure that class is inherited twice to class D.One inherited through class B(i.e. B's A) and second inherited through class C(i.e. C's A).So when we instantiate class D's object ambiguity arises as to which A's constructor to be called B's A or C's A. This confuses compiler and it displays error.
* In C++, multiple inheritance is achieved and at the same time diamond roblem is removed by using virtual keyword on classes  which uses pointers.
* But Java does not use pointers. So, it cannot remove diamond problem using classes.
* So we have interfaces in Java to prevent diamond problem.
![picture alt](https://github.com/mittulmandhan/java-interview-prep/blob/master/img/interface/multiple%20inheritance%20using%20inheritance.jpg)
<br>A & B are interfaces both having different ab() method. When class implements A,B then ab() of B will override ab() of A. And everytime jvm calls ab() method it will be of class C.
* A class can implement one or more interfaces.
* A class can extend another class and at the same time it can implement one or more interfaces as well.
````
interface A {
}
````
````
class B /*extends Object*/ imlements A {
  // class B is passing 3 IS-A Test
  // B IS-A B
  // B IS-A A
  // B IS-A Object
  // So, both of these following lines are valid
  A a = new B();
  Object obj = new B();
}
````
* An interface can extend one or more interfaces.
````
interface B {
  void my();
}
````
````
interface E {
}
````
````
// interface extending multiple interfaces
interface A extends B,E {
  void ab();
}
````

## Variables in Interface
* Variables in interface are by default `public static final`.
<br>eg:
````
interface A {
  public static final int x=10;
  // this line will not compile 
  // because y is final
  // replace this line with `int y=10;`
  // and it will compile
  // int y;
}
````
````
class B {
  public static void main(String[] args) {
    // All of this statements are valid
    // as x & y are static member of interface A
    // as B implements A
    // and x & y are inherited in B
    System.out.println(x);
    System.out.println(B.x);
    System.out.println(A.x);
  }
}
````
__output:__
````
10
10
10
````
> __Why variables in interface are static and final?__<br>Interface variables are static because Java interfaces cannot be instantiated in their own right; the value of the variable must be assigned in a static context in which no instance exists. The final modifier ensures the value assigned to the interface variable is a true constant that cannot be re-assigned by program code.


## Examples
* Example 1:
````
interface A {
  void ab();
}
````
````
class B implements A {
	public void ab() {
		System.out.println("in ab()");
	}

	public static void main(String[] args) {
		// this line will give compile time error
		// because we are trying to instantiated interface A
		// A a=new A();

		// this line will compile
		// because we are instantiating class B's object
		// and storing the object reference in a
		// reference variable of type interface A
		A obj = new B();
		obj.ab();
	}
}
````
__output:__
````
in ab()
````
* Example 2:
````
// In interface A, ab() is made public abstract by compiler
interface A {
  void ab();
}
````
````
// Here, class B is overriding interface A's ab() method
// so it followed the same signature present in interface A for overriding ab()
// In abstract class B, my() method will not be made `public abstract` by compiler
// because it is a feature present in interfaces only
abstract class B extends A {
  public abstract void ab();
  abstract void my();
}
````
````
// Now, in class C signature of ab() will be
// `public void ab()`
// and signature of my() will be
// `void my()`
// as my() have default access modifier in class B
class C extends B {
  public void ab() {
  }
  
  void my() {
  }
}
````
* Example 3:
````
interface A {
  void ab();
}
````
````
interface B {
  void my();
}
````
````
//Here, class C is implementing 2 interfaces which is an example multiple inheritance
//And class C is abstract too
//so it can hold abstract methods too
//Now, we have override ab() method but not my() method
//So now child class D is obliged to override my() method unless class D is abstract
abstract class C implements A, B {
	public void ab() {
		System.out.println("in ab()");
	}
}
````
````
//class D is not abstract
//so we need to override remaining abstract method only
//i.e. my() method
class D extends C {
	public void my() {
		System.out.println("in my()");
	}

	public static void main(String[] args) {
		D d = new D();
		d.ab();
		d.my();
	}
}
````
__output:__
````
in ab()
in my()
````
* Example 4:
````
interface A {
  void ab();
}
````
````
interface B {
  void ab();
}
````
````
// Here, interface A's ab() method will be loaded in the method table 
// then B's ab() method table will override it
// and atlast class C's ab() method override class B's ab() method
class C implements A,B {
  public void ab() {
    System.out.println("in ab()");
  }
  
  public static void main(String[] args) {
    C c = new C();
    c.ab();
  }
}
````
__output:__
````
in ab()
````
* Example 5:
````
interface A {
  String toString();
}
````
````
//There is one toString() method in interface A
//and one toString() method in Object class
//interface A's toString() method overrides the Object class' toString() method
//and interface A's toString() method is overridden by class B's toString() method
class B /* extends Object */ implements A {
	public String toString() {
		return "Hello";
	}

	public static void main(String[] args) {
		B b = new B();
		System.out.println(b.toString());
	}
}
````
__output:__
````
Hello
````
* Example 6:
````
interface A {
  int x=10;
}
````
````
interface B {
  int x=20;
}
````
````
// variables are not overriden like methods
class C implements A,B {
  public static void main(String[] args) {
    // for class C, A.x and B.x are different
    // so writting only x will confuse compiler
    // and compiler will give error
    System.out.println(x);
  }
}
````
* Example 7:
````
// Since there is no static block & we have not initialized x in declaration
// 
interface A {
  int x;
}
````
* Example 8:
````
interface A {
	void ab();
}
````
````
interface B {
	int ab();
}
````
````
// interface A has ab() method with return type void
// whereas interface B has ab() method with return type int
// this conflict will give compile error
// it can be resolved if we change the return type of ab() in either A or B

class C implements A,B {

	public void ab() {
		
	}

}
````

__Resources:__
* https://www.javatpoint.com/interface-in-java
* https://www.geeksforgeeks.org/virtual-base-class-in-c/
* https://stackoverflow.com/questions/2430756/why-are-interface-variables-static-and-final-by-default
